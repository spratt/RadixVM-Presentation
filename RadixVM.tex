%% CS854 RadixVM Presentation
%% Winter 2016

%%% BEGIN PREAMBLE
\documentclass[aspectratio=169]{beamer}
\usepackage{hyperref}
\usepackage{color}

%% Smart underlining -- from cdi-macros.tex
\def\ul#1{$\underline{\smash{\hbox{#1}}}$}

% TikZ packages (for graphs)
\usepackage{tkz-graph}
\usepackage{tkz-berge}
\usepackage{gnuplot-lua-tikz}
\usetikzlibrary{snakes}
\usetikzlibrary{backgrounds}

%% Shortcuts

\newcommand\vm{RadixVM}

\newcommand{\bi}{\begin{itemize}}
\newcommand{\ei}{\end{itemize}}

\newcommand{\bn}{\begin{enumerate}}
\newcommand{\en}{\end{enumerate}}

\newcommand{\bd}{\begin{description}}
\newcommand{\ed}{\end{description}}

\mode<presentation>
{
  \usetheme{Madrid}
  \useinnertheme{circles}
  \usecolortheme{beaver}
}
\usepackage[english]{babel}

\usepackage{times}
\usepackage[T1]{fontenc}
% Note that the encoding and the font should match. If T1 does not
% look nice, try deleting the line with the fontenc.

\title{RadixVM}
\subtitle{Scalable address spaces for multithreaded applications}

\author[Presented by Simon Pratt]{Austin T. Clements,\\M. Frans Kaashoek,\\Nickolai Zeldovich\\
  \vspace{2em}Presented by Simon Pratt}

\date{February 12, 2016}


%%% BEGIN DOCUMENT
\begin{document}

\frame[plain]{\titlepage}

\newpage

\begin{frame}{Abstract}
  RadixVM is a virtual memory (VM) design that attempts to increase multithreaded scalability by:
  \bi
\item Storing VM information in a radix tree
\item Counting references to memory addresses
\item Reducing inter-core virtual address invalidation\\(remote TLB shootdown)
  \ei
\end{frame}

\section{Background}

\begin{frame}{Background: Virtual Memory}
  \begin{columns}[T]
    \begin{column}{0.3\textwidth}
      \includegraphics[scale=0.2]{./figures/Virtual_memory.png}
    \end{column}
    \begin{column}{0.7\textwidth}
      \bi
    \item Maps a contiguous virtual address space to:
      \bi
    \item physical memory (frames)
    \item disk (swap)
      \ei
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Background: \texttt{malloc} and \texttt{mmap}}
  \begin{columns}[T]
    \begin{column}{0.2\textwidth}
      \includegraphics[scale=0.05]{./figures/Address_space.png}
    \end{column}
    \begin{column}{0.8\textwidth}
      \bi
    \item \texttt{malloc} and \texttt{free}
      \bi
    \item User-level library function
    \item Allocates/frees space in virtual memory
    \item Often implemented using \texttt{mmap} and \texttt{munmap}
      \ei
    \item \texttt{mmap} and \texttt{munmap}
      \bi
    \item System calls
    \item Actually allocates/frees space in virtual memory
      \ei
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Background: Linux Virtual Memory}
  \begin{center}
    \includegraphics[scale=0.2]{./figures/Red-black_tree.png}
  \end{center}
    \bi
    \item Red-black tree
    \item Allows the kernel to search for memory area covering a virtual address
      \pause
    \item \color{red}{Problem: A single lock per address space!}
    \ei
\end{frame}

\begin{frame}{Aside: Psearchy}
  \begin{center}
    \includegraphics[scale=0.2]{./figures/Red-black_tree.png}
  \end{center}
    \bi
  \item {\color{red}A single lock on this structure} $\rightarrow$ \texttt{mmap} within a single process is serialized
    \item This is probably why the prwlock paper notes that Psearchy is \texttt{mmap}-intensive
    \ei
\end{frame}

\section{Design}

\begin{frame}{Design: High-level}
  \begin{columns}[T]
    \begin{column}{0.3\textwidth}
    \end{column}
    \begin{column}{0.4\textwidth}
      RadixVM has 3 parts:
      \bi
      \pause
    \item {\color<5>{red}Refcache}
      \pause
    \item Radix-tree-like data structure
      \pause
    \item Targeted TLB shootdowns
      \ei
    \end{column}
    \begin{column}{0.3\textwidth}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Background: ABA Problem}
  \begin{columns}[T]
    \begin{column}{0.1\textwidth}
        \vspace{2cm}
        \begin{tikzpicture}[node distance=1cm,overlay]
          \tikzstyle{every node}=[draw]
          % nodes 
          \node<1-2> (A) {A};
          \node (head) [above of=A,node distance=2cm] {head};
          \node<1-3> (B) [right of=A] {B};
          \node (C) [right of=B] {C};
          \node (null) [right of=C] {null};
          \node<5-7> (A2) {A};
          \node<8-> (B2) [right of=A,red] {B};
          % edges
          \draw<1-2> [->,snake=snake] (head) to (A);
          \draw<3> [->,snake=snake] (head) to (B);
          \draw<4> [->,snake=snake] (head) to (C);
          \draw<5-7> [->,snake=snake] (head) to (A2);
          \draw<8-> [->,snake=snake] (head) to (B2);
          \draw<1-2> [->] (A) to (B);
          \draw<1-3> [->] (B) to (C);
          \draw<5-7> [->] (A2) to (C);
          \draw [->] (C) to (null);
        \end{tikzpicture}
    \end{column}
    \begin{column}{0.6\textwidth}
      \bi
    \item Process $P_1$ reads values $A,B$ in order to pop $A$
      \pause
    \item $P_1$ is preempted
      \pause
    \item $P_2$ pops $A$, sets head to $B$
      \pause
    \item $P_2$ pops $B$, sets head to $C$
      \pause
    \item $P_2$ pushes $A$, sets head to $A$
      \pause
    \item $P_2$ is preempted
      \pause
    \item $P_1$ reads value $A$, assumes nothing has changed
      \pause
    \item {\color{red}$P_1$ pops $A$, sets head to $B$}
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Design: Refcache}
  \begin{center}
  \includegraphics[scale=0.9]{./figures/refcache.pdf}
  \end{center}
  \begin{columns}[T]
    \begin{column}{0.4\textwidth}
    \end{column}
    \begin{column}{0.6\textwidth}
      \bi
    \item Counts references to memory locations
    \item Divides time into epochs
    \item Ref. count zero for an entire epoch $\rightarrow$ free
    \item Solves the ABA problem
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Design: High-level}
  \begin{columns}[T]
    \begin{column}{0.3\textwidth}
    \end{column}
    \begin{column}{0.4\textwidth}
      RadixVM has 3 parts:
      \bi
    \item Refcache
    \item {\color<2>{red}Radix-tree-like data structure}
    \item Targeted TLB shootdowns
      \ei
    \end{column}
    \begin{column}{0.3\textwidth}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Background: Radix Tree}
  \begin{columns}[T]
    \begin{column}{0.5\textwidth}
      \begin{center}
        \includegraphics[scale=0.6]{./figures/Patricia_trie.png}
      \end{center}
    \end{column}
    \begin{column}{0.5\textwidth}
      \bi
    \item A.K.A. prefix tree
    \item Edges labeled
    \item Concatenation of edge labels along root$\rightarrow$node path gives a string
    \item In OSes, usually strings of bits
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Design: RadixVM Data Structure}
  \begin{center}
  \includegraphics[scale=1.5]{./figures/radix.pdf}
  \end{center}
  \begin{columns}[T]
    \begin{column}{0.2\textwidth}
    \end{column}
    \begin{column}{0.6\textwidth}
      \bi
    \item Similar to a radix-tree
    \item Fixed-height
    \item Each level indexed by up to 9 bits
      \ei
    \end{column}
    \begin{column}{0.2\textwidth}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Design: High-level}
  \begin{columns}[T]
    \begin{column}{0.3\textwidth}
    \end{column}
    \begin{column}{0.4\textwidth}
      RadixVM has 3 parts:
      \bi
    \item Refcache
    \item Radix-tree-like data structure
    \item {\color<2>{red}Targeted TLB shootdowns}
      \ei
    \end{column}
    \begin{column}{0.3\textwidth}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Background: Remote TLB Shootdowns}
  \begin{columns}[T]
    \begin{column}{0.1\textwidth}
      \vspace{2cm}
      \begin{tikzpicture}[node distance=1.5cm,overlay]
        \tikzstyle{every node}=[draw]
        % nodes 
        \node (M) {$M$};
        \node (P2) [above of=M] {$CPU_2$};
        \node (P4) [below of=M] {$CPU_4$};
        \node (P1) [left of=P2,node distance=1.5cm] {$CPU_1$};
        \node (P3) [left of=P4,node distance=1.5cm] {$CPU_3$};
        % edges
        \draw<1-3> [->,snake=snake] (P1) to (M);
        \draw<1-3> [->,snake=snake] (P3) to (M);
        \draw<3-> [->,blue] (P1) to (P2);
        \draw<3-> [->,blue] (P1) to (P3);
        \draw<3-> [->,blue] (P1) to (P4);
      \end{tikzpicture}
    \end{column}
    \begin{column}{0.5\textwidth}
      \bi
    \item Processes on $CPU_1$ and $CPU_3$ share memory area $M$
      \pause
    \item A process on $CPU_1$ unmaps $M$
      \pause
    \item The kernel sends a message to all $CPU$ to {\color{blue}flush} their TLBs
      \pause
      \pause
    \item \color{red}{This is expensive!}
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Design: Targeted TLB Shootdowns}
  \begin{columns}[T]
    \begin{column}{0.1\textwidth}
      \vspace{2cm}
      \begin{tikzpicture}[node distance=1.5cm,overlay]
        \tikzstyle{every node}=[draw]
        % nodes 
        \node (M) {$M$};
        \node (P2) [above of=M] {$CPU_2$};
        \node (P4) [below of=M] {$CPU_4$};
        \node (P1) [left of=P2,node distance=1.5cm] {$CPU_1$};
        \node (P3) [left of=P4,node distance=1.5cm] {$CPU_3$};
        % edges
        \draw<1-2> [->,snake=snake] (P1) to (M);
        \draw<1-2> [->,snake=snake] (P3) to (M);
        \draw<2-> [->,blue] (P1) to (P3);
      \end{tikzpicture}
    \end{column}
    \begin{column}{0.5\textwidth}
      \bi
    \item Store metadata on which cores may have address in TLB
      \pause
    \item Only {\color{blue}flush} TLBs on cores which may share that memory
      \pause
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Design: Do we need all 3 pieces?}
  \begin{columns}[T]
    \begin{column}{0.2\textwidth}
      TODO
    \end{column}
    \begin{column}{0.8\textwidth}
      \bi
    \item TODO
      \ei
    \end{column}
  \end{columns}
\end{frame}

\section{Evaluation}

\begin{frame}{Implementation}
  \begin{center}
    \bi
  \item Implemented on xv6
    \bi
  \item Academic OS
  \item Based on v6 Unix
  \item Rewritten in ANSI C for x86
  \item \url{https://pdos.csail.mit.edu/6.828/2014/xv6.html}
    \ei
    \ei
  \end{center}
\end{frame}

\begin{frame}{Background: Bonsai}
  \begin{columns}[T]
    \begin{column}{0.6\textwidth}
      \begin{center}
        \includegraphics[scale=0.2]{./figures/Binary_tree_rotation.png}
      \end{center}
    \end{column}
    \begin{column}{0.4\textwidth}
      \bi
    \item Designed by the same authors
    \item ``Soft'' page faults happen in parallel using RCU
    \item Uses an RCU-based balanced binary tree
    \item Maintains bounded balance rather than strict balance\\
      (this means fewer rotations)
    \item Rotations construct a new subtree rather than mutate the old one
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Application: Metis}
  \begin{columns}[T]
    \begin{column}{0.5\textwidth}
      \input{graph/wrmem.tex}
    \end{column}
    \begin{column}{0.5\textwidth}
      \bi
    \item MapReduce Library
    \item Single-server
    \item Multithreaded
    \item Stresses concurrent \texttt{mmap}s and \texttt{pagefault}s, but not concurrent \texttt{munmap}s
    \item Compiles on xv6 and linux
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Microbenchmark: Local}
  \begin{columns}[T]
    \begin{column}{0.5\textwidth}
      \input{graph/local-tput.tex}
    \end{column}
    \begin{column}{0.5\textwidth}
      \bi
    \item \texttt{mmap} a private 4KB region in shared address space
    \item Write to every page in region
    \item \texttt{munmap} region
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Microbenchmark: Pipeline}
  \begin{columns}[T]
    \begin{column}{0.5\textwidth}
      \input{graph/pipeline-tput.tex}
    \end{column}
    \begin{column}{0.5\textwidth}
      \bi
    \item Each thread \texttt{mmap} a region
    \item Write to every page in region
    \item Pass region to next thread
    \item Write to every page in passed region
    \item \texttt{munmap} region
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Microbenchmark: Global}
  \begin{columns}[T]
    \begin{column}{0.5\textwidth}
      \input{graph/global-tput.tex}
    \end{column}
    \begin{column}{0.5\textwidth}
      \bi
    \item Each thread \texttt{mmap} a 64KB region within a large region of memory
    \item All threads access all pages in random order
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Memory Overhead}
  \begin{center}
    \begin{tabular}{ l | c | c c | c }
              &        & \multicolumn{2}{c|}{Linux} & Radix tree \\
              & RSS    & VMA tree & Page table      & (rel. to Linux) \\
      \hline
      Firefox & 352 MB & 117 KB   & 1.5 MB          & 3.9 MB (2.4$\times$) \\
      Chrome  & 152 MB & 124 KB   & 1.1 MB          & 2.4 MB (2.0$\times$) \\
      Apache  & 16 MB  & 44 KB    & 368 KB          & 616 KB (1.5$\times$) \\
      MySQL   & 84 MB  & 18 KB    & 348 KB          & 980 KB (2.7$\times$) \\
    \end{tabular}
    \vspace{1em}
    \bi
  \item RSS
    \bi
  \item Resident Set Size
  \item physical memory used by a process
    \ei
  \item VMA
    \bi
  \item Virtual Memory Areas
  \item stored in a red-black tree in Linux
    \ei
    \ei
  \end{center}
\end{frame}

\begin{frame}{Summary}
  \begin{columns}[T]
    \begin{column}{0.2\textwidth}
      TODO
    \end{column}
    \begin{column}{0.8\textwidth}
      \bi
    \item TODO
      \ei
    \end{column}
  \end{columns}
\end{frame}

% Structuring a talk is a difficult task and the following structure
% may not be suitable. Here are some rules that apply for this
% solution: 

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

% - A conference audience is likely to know very little of what you
%   are going to talk about. So *simplify*!
% - In a 20min talk, getting the main ideas across is hard
%   enough. Leave out details, even if it means being less precise than
%   you think necessary.
% - If you omit details that are vital to the proof/implementation,
%   just say so once. Everybody will be happy with that.

\begin{frame}[noframenumbering]{References}
  \bi
\item Clements, Austin T., M. Frans Kaashoek, and Nickolai Zeldovich. "RadixVM: Scalable address spaces for multithreaded applications." In \emph{Proceedings of the 8th ACM European Conference on Computer Systems}, pp. 211-224. ACM, 2013.
  \bi
\item Revised version: \url{https://pdos.csail.mit.edu/papers/radixvm:eurosys13-2014-08-05.pdf}
  \ei
\item Clements, Austin T., M. Frans Kaashoek, and Nickolai Zeldovich. "Scalable address spaces using RCU balanced trees." \emph{ACM SIGPLAN Notices} 47, no. 4 (2012): 199-210.
  \bi
\item Available online: \url{https://pdos.csail.mit.edu/papers/rcuvm:asplos12.pdf}
  \ei
\item Linux VM info from:\\ \url{http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/}
  \ei
\end{frame}

\begin{frame}[noframenumbering]{Attribution}
  \bi
\item Refcache diagram, radix data structure diagram, and RadixVM charts used with permission by Austin Clements
\item Virtual memory diagram by Ehamberg (Own work) [CC BY-SA 3.0 (\url{http://creativecommons.org/licenses/by-sa/3.0}) or GFDL (\url{http://www.gnu.org/copyleft/fdl.html})], via Wikimedia Commons
\item Address space diagram by Majenko (Own work) [CC BY-SA 4.0 (\url{http://creativecommons.org/licenses/by-sa/4.0})], via Wikimedia Commons
\item Patricia trie diagram by Saffles (Microsoft Visio) [GFDL (\url{http://www.gnu.org/copyleft/fdl.html}) or CC BY-SA 3.0 (\url{http://creativecommons.org/licenses/by-sa/3.0})], via Wikimedia Commons
  \item Binary tree rotation diagram by Josell7 (Own work) [CC BY-SA 3.0 (\url{http://creativecommons.org/licenses/by-sa/3.0})], via Wikimedia Commons
  \ei
\end{frame}

\begin{frame}[noframenumbering]{License}
  \bi
\item These slides are distributed under the creative commons
  Attribution-ShareAlike 4.0 International (CC BY-SA 4.0).
\item See http://creativecommons.org/licenses/by-sa/4.0/ for details.
  \ei
\end{frame}

\end{document}



